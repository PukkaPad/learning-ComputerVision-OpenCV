
# coding: utf-8

# # Transformation
# 
# Image transformations can be divided into **Affine** and **Non-Affine**.
# 
# **1) Affine transformation**
# 
# Is a generalization of Eucliden transformation (preserves distances, (more [here](https://en.wikipedia.org/wiki/Rigid_transformation))). The affine transformation preserve ratios of distances between points lying on a straight line. . It is used to correct distortion. The affine transformation is used for scaling, skewing and rotation.
# 
# The general representation of affine matrix is:
# 
# $\begin{bmatrix}a1 & a2 & b1\\a3 & a4 & b2\\c1 & c2 & 1\end{bmatrix}$
# 
# Where:
# 
# $\begin{bmatrix}a1 & a2 \\a3 & a4 \end{bmatrix}$ is the rotation matrix, which defines the transformation that will be performed (scaling, skewing and rotation).
# 
# $\begin{bmatrix}b1\\b2\end{bmatrix}$ is the translation vector, which moves the points. $b1$ represents the shift along the x-axis and $b2$ along the vertical axis.
# 
# $\begin{bmatrix}c1 & c2 \end{bmatrix}$ is the translation vector, which is = 0 for affice transformations
# 
# Given $x$ and $y$ as coordinates of a point, the transformamed coordinates $x'$ and $y'$ can be achieved by
# 
# $\begin{bmatrix}a1 & a2 & b1\\a3 & a4 & b2\\c1 & c2 & 1\end{bmatrix}$ $\times$ $\begin{bmatrix}x\\y\\1\end{bmatrix}$ = $\begin{bmatrix}x'\\y'\\1\end{bmatrix}$
# 
# 
# 1.1) Translation
# 
# All points are translated to new positions by adding offsets. $cv2.warpAffine$ to implement translations.
# 
# T= $\begin{bmatrix}1 & 0 & Tx\\0 & 1 & Ty\end{bmatrix}$ is the translation matrix
# 
# 1.2) Rotation
# 
# All points in the plane are rotated about apoint (such as the center) through the counterclockwise angle $\theta$. $cv2.getRotationMatrix2D$ to implement 2D rotations (and also scale).
# 
# M= $\begin{bmatrix}cos\theta & -sin\theta\\sin\theta & cos\theta\end{bmatrix}$ is the rotation matrix
# 
# 1.3) Resizing/scaling and interpolation
# 
# Points are scaled by applying scale factors to coordnates. Enlargements = + scale factors that are larger than unity. Reductions = + scale factors that are smaller than unity. Negative scale factors = mirrored image.
# 
# Interpolation: method of constructing new data points whthin a range of known data points.
# 
# $cv2.resize$
# 
# 
# **2) Non-affine transformation (aka Projective transform or Homography):**
# 
# It is transformation that maps lines to lines (but does not necessarily preserve parallelism). It does preserve co-linearity and incidence. Non-affine transforms result when the third row of the transform matrix is set to values other than 0, 0, and 1. It is generated by different camera angles.

# In[3]:


import cv2
import urllib
from skimage import io
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib import colors
get_ipython().magic(u'matplotlib inline')
plt.rcParams['figure.figsize'] = (10.0, 10.0)

import warnings
warnings.filterwarnings('ignore')


# ## Translation

# In[4]:


image = cv2.imread("./images/out_3.png")


# In[5]:


# store heigh and width of image
height, width = image.shape[:2]


# In[6]:


# I will move the image 1/4 of the heigh and width in y and y
quarter_height, quarter_width = height/4, width/4


# In[9]:


# create the translation matrix
T = np.float32([[1,0, quarter_width], [0, 1, quarter_height]])


# In[10]:


# translate the image
img_translation = cv2.warpAffine(image, T, (width, height))


# In[11]:


# Because I am viewing here:
#cv2.imshow('Translation', img_translation)
#cv2.waitKey()
#cv2.destroyAllWindows()
RGB_image = cv2.cvtColor(img_translation, cv2.COLOR_BGR2RGB)
io.imshow(RGB_image)
io.show()


# In[12]:


# Check the translation matrix
print(T)


# In[14]:


print(height, width)


# ## Rotation

# In[16]:


# Create rotation matrix 
# rotating around the centre. 90 degree. scale = 1
rotation_matrix = cv2.getRotationMatrix2D((width/2, height/2), 90, 1)


# In[17]:


rotated_image = cv2.warpAffine(image, rotation_matrix, (width, height))

#cv2.imshow('Rotated Image', rotated_image)
#cv2.waitKey()
#cv2.destroyAllWindows()
RGB_image = cv2.cvtColor(rotated_image, cv2.COLOR_BGR2RGB)
io.imshow(RGB_image)
io.show()


# In[22]:


# need to remove the dark area: cv2.transpose
# it only does at 90degrees and clockwise
rotated_image=cv2.transpose(image)
RGB_image = cv2.cvtColor(rotated_image, cv2.COLOR_BGR2RGB)
io.imshow(RGB_image)
io.show()


# ## Scaling/resizing and interpolation

# Note that when keeping the proportions of the image, it will be impossible to notice any change.

# In[23]:


# fx and fy: scaling 3/4 of the original size.
image_scaled = cv2.resize(image, None, fx=0.75, fy=0.75) # fx and fy: scaling 3/4 of the original size.
# default interpolation is linear
#cv2.imshow('Scaling - Linear Interpolation', image_scaled) 
#cv2.waitKey()

RGB_image = cv2.cvtColor(image_scaled, cv2.COLOR_BGR2RGB)
io.imshow(RGB_image)
io.show()


# In[24]:


# change only x
image_scaled = cv2.resize(image, None, fx=0.75, fy=1) # fx 3/4 of the original size.
# default interpolation is linear

#cv2.imshow('Scaling - Linear Interpolation', image_scaled) 
#cv2.waitKey()

RGB_image = cv2.cvtColor(image_scaled, cv2.COLOR_BGR2RGB)
io.imshow(RGB_image)
io.show()


# In[25]:


# Double the size
img_scaled = cv2.resize(image, None, fx=2, fy=2, interpolation = cv2.INTER_CUBIC)
#cv2.imshow('Scaling - Cubic Interpolation', img_scaled)
#cv2.waitKey()

RGB_image = cv2.cvtColor(img_scaled, cv2.COLOR_BGR2RGB)
io.imshow(RGB_image)
io.show()


# In[26]:


# Skew the re-sizing by setting exact dimensions
img_scaled = cv2.resize(image, (900, 400), interpolation = cv2.INTER_AREA)
#cv2.imshow('Scaling - Skewed Size', img_scaled) 
#cv2.waitKey()

#cv2.destroyAllWindows()
RGB_image = cv2.cvtColor(img_scaled, cv2.COLOR_BGR2RGB)
io.imshow(RGB_image)
io.show()

